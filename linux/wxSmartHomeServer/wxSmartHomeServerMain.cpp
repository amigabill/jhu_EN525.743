/***************************************************************
 * Name:      wxSmartHomeServerMain.cpp
 * Purpose:   Code for Application Frame
 * Author:    Bill Toner (wtoner1@jhu.edu)
 * Created:   2015-11-17
 * Copyright: Bill Toner (2015)
 * License:
 * Initially generated by wxSmith GUI builder tool
 **************************************************************/

#include "wxSmartHomeServerMain.h"

//(*InternalHeaders(wxSmartHomeServerFrame)
#include "wx/defs.h"
#include "wx/wxprec.h"
#include <wx/settings.h>
#include <wx/string.h>
#include <wx/intl.h>
#include <wx/bitmap.h>
#include <wx/image.h>
#include <wx/msgdlg.h>
#include <wx/dir.h>
//*)

#include "SmartHomeServerAppDetails.h"


// basic file operations
#include <iostream>
#include <fstream>
using namespace std;

#include <stdio.h>
#define FILE_READ "r"            // Read-only from beginning of file
#define FILE_APPEND_UPDATE "a+"  // Create file if not already there, Read from beginning, Write to end

//helper functions
enum wxbuildinfoformat {
    short_f, long_f };


//#define __UNIX__
//#define wxUSE_UNICODE

wxString wxbuildinfo(wxbuildinfoformat format)
{
    wxString wxbuild(wxVERSION_STRING);

    if (format == long_f )
    {
#if defined(__WXMSW__)
        wxbuild << _T("-Windows");
#elif defined(__UNIX__)
        wxbuild << _T("-Linux");
#endif

#if wxUSE_UNICODE
        wxbuild << _T("-Unicode build");
#else
        wxbuild << _T("-ANSI build");
#endif // wxUSE_UNICODE
    }

    return wxbuild;
}

//(*IdInit(wxSmartHomeServerFrame)
const long wxSmartHomeServerFrame::ID_TEXTCTRL_SH_EVT_LOG = wxNewId();
const long wxSmartHomeServerFrame::ID_GAUGE_SH_LD = wxNewId();
const long wxSmartHomeServerFrame::ID_BITMAPBUTTON_SH_UP = wxNewId();
const long wxSmartHomeServerFrame::ID_BITMAPBUTTON_SH_FAV = wxNewId();
const long wxSmartHomeServerFrame::ID_BITMAPBUTTON_SH_DWN = wxNewId();
const long wxSmartHomeServerFrame::ID_STATICTEXT1 = wxNewId();
const long wxSmartHomeServerFrame::ID_STATICLINE1 = wxNewId();
const long wxSmartHomeServerFrame::ID_BITMAPBUTTON_SH_ON = wxNewId();
const long wxSmartHomeServerFrame::ID_BITMAPBUTTON_SH_OFF = wxNewId();
const long wxSmartHomeServerFrame::ID_BITMAPBUTTON_SH_RM_LFT = wxNewId();
const long wxSmartHomeServerFrame::ID_BITMAPBUTTON_SH_LD_LFT = wxNewId();
const long wxSmartHomeServerFrame::ID_BITMAPBUTTON_SH_RM_RT = wxNewId();
const long wxSmartHomeServerFrame::ID_BITMAPBUTTON_SH_LD_RT = wxNewId();
const long wxSmartHomeServerFrame::ID_CHECKBOX_SH_HM1 = wxNewId();
const long wxSmartHomeServerFrame::ID_CHECKBOX_SH_HM2 = wxNewId();
const long wxSmartHomeServerFrame::ID_STATICTEXT_SH_RM_NAME = wxNewId();
const long wxSmartHomeServerFrame::ID_STATICTEXT_SH_LD_NAME = wxNewId();
const long wxSmartHomeServerFrame::ID_STATICBITMAP1 = wxNewId();
const long wxSmartHomeServerFrame::ID_STATICBITMAP2 = wxNewId();
const long wxSmartHomeServerFrame::ID_STATICBITMAP3 = wxNewId();
const long wxSmartHomeServerFrame::ID_STATICBITMAP4 = wxNewId();
const long wxSmartHomeServerFrame::ID_PANEL1 = wxNewId();
const long wxSmartHomeServerFrame::idMenuQuit = wxNewId();
const long wxSmartHomeServerFrame::idMenuAbout = wxNewId();
const long wxSmartHomeServerFrame::ID_STATUSBAR1 = wxNewId();
const long wxSmartHomeServerFrame::ID_TEXTCTRL_SH_CURTIME = wxNewId();
const long wxSmartHomeServerFrame::ID_TEXTCTRL_SH_CURDATE = wxNewId();
const long wxSmartHomeServerFrame::ID_TEXTCTRL_SH_ROOMNAME = wxNewId();
const long wxSmartHomeServerFrame::ID_TEXTCTRL_SH_LOADNAME = wxNewId();
//*)

BEGIN_EVENT_TABLE(wxSmartHomeServerFrame,wxFrame)
    //(*EventTable(wxSmartHomeServerFrame)
    //*)

    // idle "event", serving as a place for "main loop" code to go when no other events are pending
//    EVT_IDLE(wxSmartHomeServerFrame::OnIdle)

    // SmartHome GUI button events
    EVT_BUTTON(ID_BITMAPBUTTON_SH_RM_RT, wxSmartHomeServerFrame::OnshBMPbtnRoomRightClick)
    EVT_BUTTON(ID_BITMAPBUTTON_SH_RM_LFT, wxSmartHomeServerFrame::OnshBMPbtnRoomLeftClick)
    EVT_BUTTON(ID_BITMAPBUTTON_SH_LD_RT, wxSmartHomeServerFrame::OnshBMPbtnLoadRightClick)
    EVT_BUTTON(ID_BITMAPBUTTON_SH_LD_LFT, wxSmartHomeServerFrame::OnshBMPbtnLoadLeftClick)
    EVT_BUTTON(ID_BITMAPBUTTON_SH_UP, wxSmartHomeServerFrame::OnshBMPbtnIncIntClick)
    EVT_BUTTON(ID_BITMAPBUTTON_SH_FAV, wxSmartHomeServerFrame::OnshBMPbtnFavIntClick)
    EVT_BUTTON(ID_BITMAPBUTTON_SH_DWN, wxSmartHomeServerFrame::OnshBMPbtnDecIntClick)
    EVT_BUTTON(ID_BITMAPBUTTON_SH_ON, wxSmartHomeServerFrame::OnshBMPbtnOnClick)
    EVT_BUTTON(ID_BITMAPBUTTON_SH_OFF, wxSmartHomeServerFrame::OnshBMPbtnOffClick)
END_EVENT_TABLE()

wxSmartHomeServerFrame::wxSmartHomeServerFrame(wxWindow* parent,wxWindowID id)
{
    //(*Initialize(wxSmartHomeServerFrame)
    wxMenuItem* MenuItem2;
    wxMenuItem* MenuItem1;
    wxMenu* Menu1;
    wxBoxSizer* BoxSizer1;
    wxMenuBar* MenuBar1;
    wxMenu* Menu2;

    // TODO - change paths to BMP image files to inside of /home/smarthome/.wxSmartHome/IMAGES/
    //        OR some tool install path, I have not yet worked out a tool installation dir tree

    Create(parent, wxID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxDEFAULT_FRAME_STYLE, _T("wxID_ANY"));
    BoxSizer1 = new wxBoxSizer(wxHORIZONTAL);
    shPanel1 = new wxPanel(this, ID_PANEL1, wxDefaultPosition, wxSize(840,480), wxNO_BORDER|wxTAB_TRAVERSAL, _T("ID_PANEL1"));
    shPanel1->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_INFOBK));
    shTextCtrlEvtlog = new wxTextCtrl(shPanel1, ID_TEXTCTRL_SH_EVT_LOG, _("Text"), wxPoint(272,64), wxSize(560,368), wxTE_AUTO_SCROLL|wxTE_MULTILINE|wxTE_READONLY|wxTE_LEFT, wxDefaultValidator, _T("ID_TEXTCTRL_SH_EVT_LOG"));
    shTextCtrlEvtlog->SetMaxSize(wxSize(-1,-1));
    shTextCtrlEvtlog->SetForegroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_HIGHLIGHTTEXT));
    shTextCtrlEvtlog->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_3DDKSHADOW));
    shIntensityGauge = new wxGauge(shPanel1, ID_GAUGE_SH_LD, 100, wxPoint(8,102), wxSize(28,172), wxGA_VERTICAL, wxDefaultValidator, _T("ID_GAUGE1"));
    shIntensityGauge->SetValue(30);
    shBMPbuttonUP = new wxBitmapButton(shPanel1, ID_BITMAPBUTTON_SH_UP, wxBitmap(wxImage(_T("/home/billt/projects/jhu_EN525.743/arduino/SDcard_tmpl8s/UP.BMP"))), wxPoint(64,94), wxDefaultSize, wxBU_AUTODRAW|wxNO_BORDER, wxDefaultValidator, _T("ID_BITMAPBUTTON_SH_UP"));
    shBMPbuttonFAV = new wxBitmapButton(shPanel1, ID_BITMAPBUTTON_SH_FAV, wxBitmap(wxImage(_T("/home/billt/projects/jhu_EN525.743/arduino/SDcard_tmpl8s/FAV.BMP"))), wxPoint(48,158), wxDefaultSize, wxBU_AUTODRAW|wxNO_BORDER, wxDefaultValidator, _T("ID_BITMAPBUTTON_SH_FAV"));
    shBMPbuttonDWN = new wxBitmapButton(shPanel1, ID_BITMAPBUTTON_SH_DWN, wxBitmap(wxImage(_T("/home/billt/projects/jhu_EN525.743/arduino/SDcard_tmpl8s/DOWN.BMP"))), wxPoint(64,230), wxDefaultSize, wxBU_AUTODRAW|wxNO_BORDER, wxDefaultValidator, _T("ID_BITMAPBUTTON_SH_DWN"));
    StaticText1 = new wxStaticText(shPanel1, ID_STATICTEXT1, _("  SmartHome Event Log  "), wxPoint(280,16), wxDefaultSize, 0, _T("ID_STATICTEXT1"));
    StaticText1->SetForegroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_HIGHLIGHTTEXT));
    StaticLine1 = new wxStaticLine(shPanel1, ID_STATICLINE1, wxPoint(272,40), wxSize(560,16), wxLI_HORIZONTAL, _T("ID_STATICLINE1"));
    StaticLine1->SetForegroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_ACTIVECAPTION));
    shBMPbuttonON = new wxBitmapButton(shPanel1, ID_BITMAPBUTTON_SH_ON, wxBitmap(wxImage(_T("/home/billt/projects/jhu_EN525.743/arduino/SDcard_tmpl8s/ON.bmp"))), wxPoint(152,94), wxDefaultSize, wxBU_AUTODRAW|wxNO_BORDER, wxDefaultValidator, _T("ID_BITMAPBUTTON_SH_ON"));
    shBMPbuttonOFF = new wxBitmapButton(shPanel1, ID_BITMAPBUTTON_SH_OFF, wxBitmap(wxImage(_T("/home/billt/projects/jhu_EN525.743/arduino/SDcard_tmpl8s/OFF.BMP"))), wxPoint(152,190), wxDefaultSize, wxBU_AUTODRAW|wxNO_BORDER, wxDefaultValidator, _T("ID_BITMAPBUTTONSH_OFF"));
    shBMPbtnRoomLeft = new wxBitmapButton(shPanel1, ID_BITMAPBUTTON_SH_RM_LFT, wxBitmap(wxImage(_T("/home/billt/projects/jhu_EN525.743/arduino/SDcard_tmpl8s/RLBUTLFT.BMP"))), wxPoint(16,300), wxDefaultSize, wxBU_AUTODRAW|wxNO_BORDER, wxDefaultValidator, _T("ID_BITMAPBUTTON_SH_RM_LFT"));
    shBMPbtnLoadLeft = new wxBitmapButton(shPanel1, ID_BITMAPBUTTON_SH_LD_LFT, wxBitmap(wxImage(_T("/home/billt/projects/jhu_EN525.743/arduino/SDcard_tmpl8s/RLBUTLFT.BMP"))), wxPoint(16,386), wxDefaultSize, wxBU_AUTODRAW|wxNO_BORDER, wxDefaultValidator, _T("ID_BITMAPBUTTON_SH_LD_LFT"));
    shBMPbtnRoomRight = new wxBitmapButton(shPanel1, ID_BITMAPBUTTON_SH_RM_RT, wxBitmap(wxImage(_T("/home/billt/projects/jhu_EN525.743/arduino/SDcard_tmpl8s/RLBUTRIT.BMP"))), wxPoint(191,300), wxDefaultSize, wxBU_AUTODRAW|wxNO_BORDER, wxDefaultValidator, _T("ID_BITMAPBUTTON_SH_RM_RT"));
    shBMPbtnLoadRight = new wxBitmapButton(shPanel1, ID_BITMAPBUTTON_SH_LD_RT, wxBitmap(wxImage(_T("/home/billt/projects/jhu_EN525.743/arduino/SDcard_tmpl8s/RLBUTRIT.BMP"))), wxPoint(191,386), wxDefaultSize, wxBU_AUTODRAW|wxNO_BORDER, wxDefaultValidator, _T("ID_BITMAPBUTTON_SH_LD_RT"));
    shCheckBoxIsHome1 = new wxCheckBox(shPanel1, ID_CHECKBOX_SH_HM1, _("Home 1"), wxPoint(296,448), wxDefaultSize, 0, wxDefaultValidator, _T("ID_CHECKBOX_SH_HM1"));
    shCheckBoxIsHome1->SetValue(false);
    shCheckBoxIsHome2 = new wxCheckBox(shPanel1, ID_CHECKBOX_SH_HM2, _("Home 2"), wxPoint(392,448), wxDefaultSize, 0, wxDefaultValidator, _T("ID_CHECKBOX_SH_HM2"));
    shCheckBoxIsHome2->SetValue(false);

    StaticBitmap1 = new wxStaticBitmap(shPanel1, ID_STATICBITMAP1, wxBitmap(wxImage(_T("/home/billt/projects/jhu_EN525.743/arduino/SDcard_tmpl8s/TMPL8LN.BMP"))), wxPoint(80,306), wxDefaultSize, wxSIMPLE_BORDER, _T("ID_STATICBITMAP1"));
    StaticBitmap2 = new wxStaticBitmap(shPanel1, ID_STATICBITMAP2, wxBitmap(wxImage(_T("/home/billt/projects/jhu_EN525.743/arduino/SDcard_tmpl8s/TMPL8LN.BMP"))), wxPoint(80,354), wxDefaultSize, wxSIMPLE_BORDER, _T("ID_STATICBITMAP2"));
    StaticBitmap3 = new wxStaticBitmap(shPanel1, ID_STATICBITMAP3, wxBitmap(wxImage(_T("/home/billt/projects/jhu_EN525.743/arduino/SDcard_tmpl8s/TMPL8LN.BMP"))), wxPoint(80,392), wxDefaultSize, wxSIMPLE_BORDER, _T("ID_STATICBITMAP3"));
    StaticBitmap4 = new wxStaticBitmap(shPanel1, ID_STATICBITMAP4, wxBitmap(wxImage(_T("/home/billt/projects/jhu_EN525.743/arduino/SDcard_tmpl8s/TMPL8LN.BMP"))), wxPoint(80,440), wxDefaultSize, wxSIMPLE_BORDER, _T("ID_STATICBITMAP4"));

    shTextCtrlCurrentTime = new wxTextCtrl(shPanel1, ID_TEXTCTRL_SH_CURTIME, _("23:59:59"), wxPoint(50,60), wxDefaultSize, wxTE_READONLY|wxTE_LEFT|wxNO_BORDER, wxDefaultValidator, _T("ID_TEXTCTRL_SH_CURTIME"));
    shTextCtrlCurrentTime->SetMinSize(wxSize(250,20));
    shTextCtrlCurrentTime->SetForegroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNFACE));
    shTextCtrlCurrentTime->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_INFOBK));
    shTextCtrlCurrentDate = new wxTextCtrl(shPanel1, ID_TEXTCTRL_SH_CURDATE, _("Mon, Dec 01, 2015 "), wxPoint(50,20), wxDefaultSize, wxTE_READONLY|wxTE_LEFT|wxNO_BORDER, wxDefaultValidator, _T("ID_TEXTCTRL_SH_CURDATE"));
    shTextCtrlCurrentDate->SetMinSize(wxSize(250,20));
    shTextCtrlCurrentDate->SetForegroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNFACE));
    shTextCtrlCurrentDate->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_INFOBK));


    shTextCtrlRoomName = new wxTextCtrl(shPanel1, ID_TEXTCTRL_SH_ROOMNAME, _("Room Name"), wxPoint(80,325), wxDefaultSize, wxTE_READONLY|wxTE_CENTRE|wxNO_BORDER, wxDefaultValidator, _T("ID_TEXTCTRL_SH_ROOMNAME"));
    shTextCtrlRoomName->SetMinSize(wxSize(150,20));
    shTextCtrlRoomName->SetForegroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNFACE));
    shTextCtrlRoomName->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_INFOBK));
    shTextCtrlLoadName = new wxTextCtrl(shPanel1, ID_TEXTCTRL_SH_LOADNAME, _("Load Name"), wxPoint(80,410), wxDefaultSize, wxTE_READONLY|wxTE_CENTRE|wxNO_BORDER, wxDefaultValidator, _T("ID_TEXTCTRL_SH_LOADNAME"));
    shTextCtrlLoadName->SetMinSize(wxSize(150,20));
    shTextCtrlLoadName->SetForegroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNFACE));
    shTextCtrlLoadName->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_INFOBK));


    BoxSizer1->Add(shPanel1, 1, wxALL|wxEXPAND|wxFIXED_MINSIZE|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 0);
    SetSizer(BoxSizer1);

#if 0 // wxSmith gave me menubar and status bar for this App's window, but I don't want them, so comment out
    MenuBar1 = new wxMenuBar();
    Menu1 = new wxMenu();
    MenuItem1 = new wxMenuItem(Menu1, idMenuQuit, _("Quit\tAlt-F4"), _("Quit the application"), wxITEM_NORMAL);
    Menu1->Append(MenuItem1);
    MenuBar1->Append(Menu1, _("&File"));
    Menu2 = new wxMenu();
    MenuItem2 = new wxMenuItem(Menu2, idMenuAbout, _("About\tF1"), _("Show info about this application"), wxITEM_NORMAL);
    Menu2->Append(MenuItem2);
    MenuBar1->Append(Menu2, _("Help"));
    SetMenuBar(MenuBar1);
    StatusBar1 = new wxStatusBar(this, ID_STATUSBAR1, 0, _T("ID_STATUSBAR1"));
    int __wxStatusBarWidths_1[1] = { -1 };
    int __wxStatusBarStyles_1[1] = { wxSB_NORMAL };
    StatusBar1->SetFieldsCount(1,__wxStatusBarWidths_1);
    StatusBar1->SetStatusStyles(1,__wxStatusBarStyles_1);
    SetStatusBar(StatusBar1);
#endif
    BoxSizer1->Fit(this);
    BoxSizer1->SetSizeHints(this);

    // wxSmith gave me menubar and status bar for this App's window, but I don't want them, so comment out
    //Connect(ID_BITMAPBUTTON_SH_RM_RT,wxEVT_COMMAND_BUTTON_CLICKED,(wxObjectEventFunction)&wxSmartHomeServerFrame::OnshBMPbtnRoomRightClick);
    //Connect(idMenuQuit,wxEVT_COMMAND_MENU_SELECTED,(wxObjectEventFunction)&wxSmartHomeServerFrame::OnQuit)////;
    //Connect(idMenuAbout,wxEVT_COMMAND_MENU_SELECTED,(wxObjectEventFunction)&wxSmartHomeServerFrame::OnAbout);

    //*)

    shDebugLogFile.Open( SH_DEBUG_LOG_FILENAME, wxFile::write);
    shDebugLogFile.Write("Testing debug log output\n");

    // set file paths to data files to be used during runtime
  	shPathConfig = SH_SERV_PATH_CFG_DEFAULT;
  	shPathRooms  = SH_SERV_PATH_ROOMS_DEFAULT;

    // initialize the Server Node Info struct data
    SHinitServerNodeInfo();
//    wxLogMessage( "Server Node ID = 0x%.4x ; Server Node Type = %d", shThisNodeID, shThisNodeType ) ;

    // initialize default load Node Info struct data
    SHinitLoadNodeInfo();

    // update the GUI display with Room and Load names on their button areas
//    shTextCtrlRoomName->Clear();
//    shTextCtrlRoomName->AppendText(shCurrentRoomName);
    shGUIupdateRoomName(currentRoomNum);
//    shTextCtrlLoadName->Clear();
//    shTextCtrlLoadName->AppendText(shCurrentLoadName);
    shGUIupdateLoadName(currentRoomNum, currentLoadNumInRoom);

    // open the SmartHome events log file for reading AND writing, create file if necessary
    #define FILENAME_SH_EVENTS_LOG "/home/smarthome/.wxSmartHome/shEvents.log"
    FILEshEventsLog = fopen(FILENAME_SH_EVENTS_LOG, FILE_APPEND_UPDATE);
}

wxSmartHomeServerFrame::~wxSmartHomeServerFrame()
{
    //(*Destroy(wxSmartHomeServerFrame)
    //*)

    // close serial port
//    shServerSerialPort.stop();

    // close any network sockets


    // close the SmartHome events log text file
    fclose(FILEshEventsLog);

    // close the debug log text file
    shDebugLogFile.Close();
}

void wxSmartHomeServerFrame::OnQuit(wxCommandEvent& event)
{
    // close serial port
//    shServerSerialPort.stop();

    // close any network sockets


    // close the SmartHome events log file
    fclose(FILEshEventsLog);

    Close();
}

void wxSmartHomeServerFrame::OnAbout(wxCommandEvent& event)
{
    wxString msg = wxbuildinfo(long_f);
    wxMessageBox(msg, _("Welcome to wxSmartHomeServer"));
    // SH_SERV_APP_NAME
}



void wxSmartHomeServerFrame::OnshBMPbtnRoomRightClick(wxCommandEvent& event)
{
    _changeRoom(ROOM_CHANGE_ROTR);

//    wxLogMessage( "Button Room Right" ) ;
//    wxLogMessage( "Button Room Right, %d:0x%.4x", shCurrentLoadNodeInfo.SHthisNodeLoc, shCurrentLoadNodeInfo.SHthisNodeID ) ;
}

void wxSmartHomeServerFrame::OnshBMPbtnRoomLeftClick(wxCommandEvent& event)
{
    _changeRoom(ROOM_CHANGE_ROTL);

//    wxLogMessage( "Button Room Left" ) ;
//    wxLogMessage( "Button Room Left, %d:0x%.4x", currentRoomNum, currentLoadNumInRoom ) ;
}


void wxSmartHomeServerFrame::OnshBMPbtnLoadRightClick(wxCommandEvent& event)
{
    _changeLoad(LOAD_CHANGE_ROTR);

//    wxLogMessage( "Button Load Right, 0x%.4x", shCurrentLoadNodeInfo.SHthisNodeID ) ;
}

void wxSmartHomeServerFrame::OnshBMPbtnLoadLeftClick(wxCommandEvent& event)
{
    _changeLoad(LOAD_CHANGE_ROTL);

//    wxLogMessage( "Button Load Left, 0x%.4x", shCurrentLoadNodeInfo.SHthisNodeID ) ;
}


void wxSmartHomeServerFrame::OnshBMPbtnIncIntClick(wxCommandEvent& event)
{
    if(shCurrentLoadNodeInfo.SHthisNodeIsPowered == NO)
    {
        shCurrentLoadNodeInfo.SHthisNodeLevelCurrent = LOAD_INTENSITY_FULL_OFF + 1;
        shCurrentLoadNodeInfo.SHthisNodeIsPowered = YES;
    }
    else
    {
        if(shCurrentLoadNodeInfo.SHthisNodeLevelCurrent >= LOAD_INTENSITY_MAX)
        {
            shCurrentLoadNodeInfo.SHthisNodeLevelCurrent = LOAD_INTENSITY_MAX;
        }
        else
        {
            shCurrentLoadNodeInfo.SHthisNodeLevelCurrent += 1;
        }


        if( shCurrentLoadNodeInfo.SHthisNodeLevelCurrent > LOAD_INTENSITY_FULL_OFF )
        {
            shCurrentLoadNodeInfo.SHthisNodeIsPowered = YES;
        }
    }

    // send new level and powered state to the load via Zigbee


    // update the local level/intensity guage on LCD
    SHguageDrawCurrentIntensity();

//    wxLogMessage( "Button Up Inc Intensity" ) ;
}

void wxSmartHomeServerFrame::OnshBMPbtnFavIntClick(wxCommandEvent& event)
{
    shCurrentLoadNodeInfo.SHthisNodeLevelCurrent = shCurrentLoadNodeInfo.SHthisNodeLevelFav;

    if(shCurrentLoadNodeInfo.SHthisNodeIsPowered == NO)
    {
        shCurrentLoadNodeInfo.SHthisNodeIsPowered = YES;
    }

    // send new level and powered state to the load via Zigbee


    // update the local level/intensity guage on LCD
    SHguageDrawCurrentIntensity();

//    wxLogMessage( "Button FAVorite Intensity = %d", shCurrentLoadNodeInfo.SHthisNodeLevelFav ) ;
}

void wxSmartHomeServerFrame::OnshBMPbtnDecIntClick(wxCommandEvent& event)
{
    //TODO - do not make currInt = OFF, leave it one step above, so ON button has someplace to go that isn't still OFF level

    if(shCurrentLoadNodeInfo.SHthisNodeLevelCurrent <= LOAD_INTENSITY_MIN)
    {
        shCurrentLoadNodeInfo.SHthisNodeLevelCurrent = LOAD_INTENSITY_MIN;
    }
    else
    {
        shCurrentLoadNodeInfo.SHthisNodeLevelCurrent -= 1;
    }


    if( shCurrentLoadNodeInfo.SHthisNodeLevelCurrent <= LOAD_INTENSITY_FULL_OFF )
    {
        shCurrentLoadNodeInfo.SHthisNodeIsPowered = NO;
    }

    // send new level and powered state to the load via Zigbee

    // update the local level/intensity guage on LCD
    SHguageDrawCurrentIntensity();

//    wxLogMessage( "Button Down Dec Intensity" ) ;
}


// Have an ON button event
void wxSmartHomeServerFrame::OnshBMPbtnOnClick(wxCommandEvent& event)
{
    if(  NO == shCurrentLoadNodeInfo.SHthisNodeIsPowered )
    {
        // don't turn on to an OFF intensity level, turn on to first level above OFF
        if(LOAD_INTENSITY_FULL_OFF >= shCurrentLoadNodeInfo.SHthisNodeLevelCurrent)
        {
            shCurrentLoadNodeInfo.SHthisNodeLevelCurrent = LOAD_INTENSITY_FULL_OFF + 1;
        }

        shCurrentLoadNodeInfo.SHthisNodeIsPowered = YES;
//        shCurrentLoadNodeInfo.SHthisNodeLevelCurrent = shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusVal;

        // Fill TX frame payload (SH message) with current message values
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHothrID = shThisNodeID;  //SHothrID is the message sender, which is this server
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHmsgType = SH_MSG_TYPE_CMD_REQ;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHcommand = SH_CMD_LOAD_ON;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusH = 0;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusL = shCurrentLoadNodeInfo.SHthisNodeIsPowered;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusID = 0;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusVal = shCurrentLoadNodeInfo.SHthisNodeLevelCurrent;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHreserved1 = SH_RESERVED_BYTE;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHreserved2 = SH_RESERVED_BYTE;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHchksum = 0;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHcalcChksum = 0;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusTX = 0;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusRX = 0;

        // Set the xmitReady flag in the nodeinfo structure set above
        shCurrentLoadNodeInfo.newSHmsgTX = YES;
        shCurrentLoadNodeInfo.SHmsgNextState = SH_MSG_ST_CMD_INIT;

        // update the local level/intensity guage on LCD
        SHguageDrawCurrentIntensity();
    }
//    wxLogMessage( "Button On" ) ;
}


// Have an OFF button event
void wxSmartHomeServerFrame::OnshBMPbtnOffClick(wxCommandEvent& event)
{
    if(  YES == shCurrentLoadNodeInfo.SHthisNodeIsPowered )
    {
        shCurrentLoadNodeInfo.SHthisNodeIsPowered = NO; //SH_POWERED_OFF;
//        shCurrentLoadNodeInfo.SHthisNodeLevelCurrent = shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusVal;

        // Fill TX frame payload (SH message) with current message values
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHothrID = shThisNodeID;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHmsgType = SH_MSG_TYPE_CMD_REQ;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHcommand = SH_CMD_LOAD_OFF;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusH = 0;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusL = shCurrentLoadNodeInfo.SHthisNodeIsPowered; //SH_POWERED_OFF;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusID = 0;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusVal = shCurrentLoadNodeInfo.SHthisNodeLevelCurrent;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHreserved1 = SH_RESERVED_BYTE;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHreserved2 = SH_RESERVED_BYTE;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHchksum = 0;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHcalcChksum = 0;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusTX = 0;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusRX = 0;

        // Set the xmitReady flag in the nodeinfo structure set above
        shCurrentLoadNodeInfo.newSHmsgTX = YES;
        shCurrentLoadNodeInfo.SHmsgNextState = SH_MSG_ST_CMD_INIT;

        // update the local level/intensity guage on LCD
        SHguageDrawCurrentIntensity();

//        wxLogMessage( "Button Off" ) ;
    }
}


// Update the intensity/level guage drawn to new current intensity level
void wxSmartHomeServerFrame::SHguageDrawCurrentIntensity(void)
{
    if( shCurrentLoadNodeInfo.SHthisNodeIsPowered == NO )
    {
        shIntensityGauge->SetValue(0);
    }
    else
    {
        switch(shCurrentLoadNodeInfo.SHthisNodeLevelCurrent)
        {
            case 5:
                shIntensityGauge->SetValue(100);
                break;

            case 4:
                shIntensityGauge->SetValue(80);
                break;

            case 3:
                shIntensityGauge->SetValue(60);
                break;

            case 2:
                shIntensityGauge->SetValue(40);
                break;

            case 1:
                shIntensityGauge->SetValue(20);
                break;

            case 0:
                shIntensityGauge->SetValue(0);
                break;

            default:
                // for any unknown value, reset to 0
                shCurrentIntensity = 0;
                shIntensityGauge->SetValue(0);
                break;
        }
    }
}


// Initialize the currentNodeInfo struct based on data in the default load for this server from file
// DEBUG seg fault from this function call when using file access, changed to hardcoded values works
//       and hardcode is OK in cae of server due to specially assigned node ID value and type value
// change to wxFile type file access instead, if time allows
void wxSmartHomeServerFrame::SHinitServerNodeInfo(void)
{
     uint16_t    tmpNodeID = 0;
     uint8_t    *ptrTmpNodeID = (uint8_t *)&tmpNodeID;

    // file to read data from
    FILE  *FILEserverNodeInfo;
    wxString fileNameLoadData = shPathConfig + "SERVER.BIN";

    FILEserverNodeInfo = fopen(fileNameLoadData.fn_str(), FILE_READ );

    // read the node ID value
    ptrTmpNodeID[1] = (uint8_t)fgetc(FILEserverNodeInfo);  // 1st byte
    ptrTmpNodeID[0] = (uint8_t)fgetc(FILEserverNodeInfo);  // 2nd byte
    shThisNodeType  = (uint8_t)fgetc(FILEserverNodeInfo);  // 3rd byte
#if 0
    ptrThisNodeID[1] = (uint8_t)0x00;  // server node ID is special value of 0
    ptrThisNodeID[0] = (uint8_t)0x00;
    shThisNodeType = NODEINFO_NODETYPE_SERVER; //SH_NODE_TYPE_SERVER;
#endif

    // close out the file as we're done for now
    fclose(FILEserverNodeInfo);
}


// read node ID from NodeInfo struct based on data from file
// for the given room number and load number
uint16_t wxSmartHomeServerFrame::SHgetLoadNodeIDfromStorage(uint16_t roomNum, uint16_t loadNum)
{
     uint16_t    tmpNodeID = 0;
     uint8_t    *ptrTmpNodeID = (uint8_t *)&tmpNodeID;

    // file to read data from
    FILE  *FILEloadNodeInfo;
    wxString fileNameLoadData = shPathRooms + wxString::Format("%d", roomNum) + "/" + wxString::Format("%d", loadNum) + ".BIN";

    FILEloadNodeInfo = fopen(fileNameLoadData.fn_str(), FILE_READ );

    // read the node ID value
    ptrTmpNodeID[1] = (uint8_t)fgetc(FILEloadNodeInfo);  // 1st byte
    ptrTmpNodeID[0] = (uint8_t)fgetc(FILEloadNodeInfo);  // 2nd byte

    // close out the file as we're done for now
    fclose(FILEloadNodeInfo);

    return(tmpNodeID);
}


// read node type from NodeInfo struct based on data from file
// for the given room number and load number
uint8_t wxSmartHomeServerFrame::SHgetLoadNodeTypefromStorage(uint16_t roomNum, uint16_t loadNum)
{
     uint8_t     tmpNodeType = 0;

    // files to read data from
    FILE  *FILEloadNodeInfo;
    wxString fileNameLoadData = shPathRooms + wxString::Format("%d", roomNum) + "/" + wxString::Format("%d", loadNum) + ".BIN";

    FILEloadNodeInfo = fopen(fileNameLoadData.fn_str(), FILE_READ );

    // skip over other data fields
    (uint8_t)fgetc(FILEloadNodeInfo);  // 1st byte
    (uint8_t)fgetc(FILEloadNodeInfo);  // 2nd byte

    // read the node type
    tmpNodeType = (uint8_t)fgetc(FILEloadNodeInfo);  // 3rd byte

    // close out the file as we're done for now
    fclose(FILEloadNodeInfo);

    return(tmpNodeType);
}


void wxSmartHomeServerFrame::SHinitLoadNodeInfo(void)
{
    shCurrentIntensity = LOAD_INTENSITY_FULL_OFF; // 0

    shCurrentLoadNodeInfo.SHthisNodeLoc   = DEFAULT_ROOM_NUM;
    currentRoomNum = DEFAULT_ROOM_NUM;
    shCurrentRoomName                     = SHgetRoomNamefromStorage(shCurrentLoadNodeInfo.SHthisNodeLoc);
    numRooms                              = getNumRoomsFromStorage();
    lastRoomNum = numRooms - 1;

    curNumLoadsInRoom                     = getNumLoadsInRoomFromStorage(shCurrentLoadNodeInfo.SHthisNodeLoc);
    lastLoadNumInRoom                     = curNumLoadsInRoom - 1; // start at 0
    currentLoadNumInRoom                  = DEFAULT_LOAD_NUM;
    shCurrentLoadName                     = SHgetLoadNamefromStorage(shCurrentLoadNodeInfo.SHthisNodeLoc, currentLoadNumInRoom);
    shGUIupdateLoadName(currentRoomNum, currentLoadNumInRoom);

    shCurrentLoadNodeInfo.SHthisNodeID    = SHgetLoadNodeIDfromStorage(shCurrentLoadNodeInfo.SHthisNodeLoc, currentLoadNumInRoom);
    shCurrentLoadNodeInfo.SHthisNodeType  = SHgetLoadNodeTypefromStorage(shCurrentLoadNodeInfo.SHthisNodeLoc, currentLoadNumInRoom);


    shCurrentLoadNodeInfo.SHthisNodePin   = 0; // pin is an Arduino thing, not used in Server code

    shCurrentLoadNodeInfo.SHothrNodeID = shThisNodeID;  // the other node iD talking to a Load is this server
    shCurrentLoadNodeInfo.SHmsgCurrentState = SH_MSG_ST_IDLE;
    shCurrentLoadNodeInfo.SHmsgNextState = SH_MSG_ST_IDLE;
    shCurrentLoadNodeInfo.SHmsgCmd = SH_CMD_NOP;
    shCurrentLoadNodeInfo.SHmsgStatus = 0;
    shCurrentLoadNodeInfo.SHthisNodeMsg.SHothrID = shThisNodeID;
    shCurrentLoadNodeInfo.SHthisNodeMsg.SHmsgType = SH_MSG_ST_IDLE;
    shCurrentLoadNodeInfo.SHthisNodeMsg.SHcommand = SH_CMD_NOP;
    shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusH = 0;
    shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusL = 0;
    shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusID = 0;// 16bit alternative to SHstatusH and SHstatusL but represents same bytes in message
    shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusVal = 0;
    shCurrentLoadNodeInfo.SHthisNodeMsg.SHreserved1 = 'R';
    shCurrentLoadNodeInfo.SHthisNodeMsg.SHreserved2 = 'r';
    shCurrentLoadNodeInfo.SHthisNodeMsg.SHchksum = 0;
    shCurrentLoadNodeInfo.SHthisNodeMsg.SHcalcChksum = 0;
    shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusTX = 0;
    shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusRX = 0;

    shCurrentLoadNodeInfo.newSHmsgTX = NO;
    shCurrentLoadNodeInfo.newSHmsgRX = NO;

    // ask via Zigbee what these values are
    shCurrentLoadNodeInfo.SHthisNodeIsPowered = NO;
    shCurrentLoadNodeInfo.SHthisNodeLevelCurrent = 4; //0;
    shCurrentLoadNodeInfo.SHthisNodeLevelFav = 2;

//    wxLogMessage( "Default Load ID = 0x%.4x", shCurrentLoadNodeInfo.SHthisNodeID ) ;

}


// Look on SD card for number of rooms.
// Each room on SD card is a directory with same name as its room number.
// Cycle through the numbers, starting with first load number of 0 and counting up,
// until a dir name for value N is not found.
uint16_t wxSmartHomeServerFrame::getNumRoomsFromStorage(void)
{
    uint16_t tmpRoomNum=0, tmpNumRooms=0;
    wxString roomNumFileName = "0";  // default room number

    tmpRoomNum = 0;
    roomNumFileName = shPathRooms + wxString::Format("%d", tmpRoomNum);
    if( ! wxDir::Exists(roomNumFileName) )
    {
        return(ROOM_NO_LOADS);
    }
    // have at least one room, count as many as we can find
    while( (tmpRoomNum <= NUM_ROOMS_MAX) && wxDir::Exists(roomNumFileName) )
    {
        tmpNumRooms += 1;

        tmpRoomNum += 1;
        roomNumFileName = shPathRooms + wxString::Format("%d", tmpRoomNum);
    }

    return(tmpNumRooms);
}


// Look on SD card for number of loads in the given room.
// Each room on SD card is a directory with same name as its room number.
// Each load on SD is a few files with names of load number DOT extension, such as 0.BIN or 1.BIN etc.
// Cycle through the numbers, starting with first load number of 0 and counting up,
// until an N.BIN file is not found for that N value load number.
uint16_t wxSmartHomeServerFrame::getNumLoadsInRoomFromStorage(uint16_t roomNum)
{
    uint16_t tmpLoadNum=0, tmpNumLoadsInRoom=0, lastLoadNumInRoom=0;
    wxString roomNumFileName = "0";  // default room number
    wxString loadNumFileName = "/65535/255.BIN";  // default longest filename to make sure have enough chars in string

    roomNumFileName = shPathRooms + wxString::Format("%d", roomNum);
    if( ! wxDir::Exists(roomNumFileName) )
    {
        return(ROOM_NO_LOADS);
    }

    //count the number of loads in the room
    tmpLoadNum = 0;
    tmpNumLoadsInRoom = 0;
    loadNumFileName = shPathRooms + wxString::Format("%d", roomNum)
                    + "/" + wxString::Format("%d", tmpLoadNum) + ".BIN" ;
    while( (tmpLoadNum <= NUM_LOADS_MAX) && wxFile::Exists(loadNumFileName)  )
    {
        tmpLoadNum += 1;
        tmpNumLoadsInRoom += 1;
        loadNumFileName = shPathRooms + wxString::Format("%d", roomNum)
                        + "/" + wxString::Format("%d", tmpLoadNum) + ".BIN" ;
    }

//    wxLogMessage( "Room %d has %d loads in it", roomNum, tmpNumLoadsInRoom ) ;

    return(tmpNumLoadsInRoom);
}


// read the name of the selected load from a text file
// This file should be a one-line text file,
// and the line should be short enough to fit into the name label of the GUI load buttons area
wxString  wxSmartHomeServerFrame::SHgetLoadNamefromStorage(uint16_t roomNum, uint16_t loadNum)
{
    wxString tmpLoadName;

    // files to read data from
    wxString fileNameLoadData = shPathRooms + wxString::Format("%d", roomNum) + "/" + wxString::Format("%d", loadNum) + ".TXT";
    wxFile loadNameFile(fileNameLoadData, wxFile::read);

    // read the full single-line file content, which should be relatively small
    loadNameFile.ReadAll( &tmpLoadName );
//    wxLogMessage( "read load name from file = %s ; %s", fileNameLoadData, tmpRoomName ) ;

    // close out the file as we're done for now
    loadNameFile.Close();

    return(tmpLoadName);
}


// read the name of the selected room from a text file
// This file should be a one-line text file,
// and the line should be short enough to fit into the name label of the GUI load buttons area
wxString  wxSmartHomeServerFrame::SHgetRoomNamefromStorage(uint16_t roomNum)
{
    wxString tmpRoomName;

    // files to read data from
    wxString fileNameRoomData = shPathRooms + wxString::Format("%d", roomNum) + "/R.TXT";
    wxFile roomNameFile(fileNameRoomData, wxFile::read);

    // read the full single-line file content, which should be relatively small
    roomNameFile.ReadAll( &tmpRoomName );
//    wxLogMessage( "read room name from file = %s ; %s", fileNameRoomData, tmpRoomName ) ;

    // close out the file as we're done for now
    roomNameFile.Close();

    return(tmpRoomName);
}


// change room by moving one step in the given direction in the room number ID
// Rotate Right = increase room ID by 1
// Rotate Left - decrease room ID by 1
// wrap around from MAX to 0, or from 0 to MAX
void wxSmartHomeServerFrame::_changeRoom(uint8_t changeDirection)
{
   uint16_t newRoom = ROOM_FIRST;

    if(changeDirection == ROOM_CHANGE_ROTR)  // Rotate Right == Increment with wraparound back to 0
    {
        if(currentRoomNum == lastRoomNum)
        {
            newRoom = ROOM_FIRST;
        }
        else
        {
            newRoom = currentRoomNum + 1;
        }
    }
    else if(changeDirection == ROOM_CHANGE_ROTL) // Rotate Left == Decrement with wraparound back to lsat room
    {
        if(currentRoomNum == ROOM_FIRST)
        {
            newRoom = lastRoomNum;
        }
        else
        {
            newRoom = currentRoomNum - 1;
        }
    }

    selectRoom(newRoom);
}

// change room by moving one step in the given direction in the room number ID
// Rotate Right = increase room ID by 1
// Rotate Left - decrease room ID by 1
// wrap around from MAX to 0, or from 0 to MAX
void wxSmartHomeServerFrame::_changeLoad(uint8_t changeDirection)
{
    uint16_t newLoad = DEFAULT_LOAD_NUM;

    if(curNumLoadsInRoom == 1)
    {
        // if only have one load in this room then no change from current load number
        newLoad = currentLoadNumInRoom;
    }
    else if(changeDirection == LOAD_CHANGE_ROTR)  // Rotate Right == Increment with wraparound back to 0
    {
        if(currentLoadNumInRoom == lastLoadNumInRoom)
        {
            newLoad = LOAD_FIRST;
        }
        else
        {
            newLoad = currentLoadNumInRoom + 1;
        }
    }
    else if(changeDirection == LOAD_CHANGE_ROTL) // Rotate Left == Decrement with wraparound back to last load
    {
        if(currentLoadNumInRoom == LOAD_FIRST)
        {
            newLoad = lastLoadNumInRoom;
        }
        else
        {
            newLoad = currentLoadNumInRoom - 1;
        }
    }

    selectLoad(newLoad);
}

void wxSmartHomeServerFrame::selectRoom(uint16_t roomNum)
{
   uint16_t tmpNumLoadsInRoom = 0;

    if( (roomNum >= 0) && (roomNum <= lastRoomNum) )
    {
//        Serial.print("Selecting ");
//        Serial.print(roomNum, DEC);
//        Serial.println(" as current room");

        tmpNumLoadsInRoom = getNumLoadsInRoomFromStorage(roomNum);

        if( tmpNumLoadsInRoom == ROOM_NO_LOADS)
        {
            // ERROR, no loads in this room to drive, do nothing
        }
        else
        {
            // update room number
            currentRoomNum = roomNum;
            curNumLoadsInRoom = tmpNumLoadsInRoom;
        }

            lastLoadNumInRoom = curNumLoadsInRoom - 1;
            currentLoadNumInRoom = DEFAULT_LOAD_NUM;
//            curLoadID = SHgetLoadNodeIDfromStorage(roomNum, currentLoadNumInRoom);
//            curLoadNodeInfo.SHthisNodeType = SHgetLoadNodeTypefromStorage(currentRoomNum, currentLoadNumInRoom);

#if 0 // Arduino
            Serial.print("curNumLoadsInRoom = ");
            Serial.println(curNumLoadsInRoom, DEC);

            Serial.print("Current Room = ");
            Serial.print(currentRoomNum, DEC);
            Serial.print(" ; Last Room = ");
            Serial.print(lastRoomNum, DEC);
            Serial.print(" ; Current Load = ");
            Serial.print(currentLoadNumInRoom, DEC);
            Serial.print(" ; Last Load = ");
            Serial.print(lastLoadNumInRoom, DEC);
            Serial.println("");

            lcdDrawRoomBtn(roomNum);
#endif // 0
            // update the GUI display with new room name
            shGUIupdateRoomName(currentRoomNum);

            selectLoad(DEFAULT_LOAD_NUM);
    }
    else
    {
        // invalid room umber, do nothing

//        Serial.print("ERROR - Invalid room number ");
//        Serial.println(roomNum, DEC);
    }

}

// select the given load number, in the current room, as the currently controlled load by this wall control unit
void wxSmartHomeServerFrame::selectLoad(uint16_t loadNum)
{
    if( (loadNum >= 0) && (loadNum <= lastLoadNumInRoom) )
    {
        // update load number and type
        currentLoadNumInRoom = loadNum;

        shCurrentLoadNodeInfo.SHthisNodeLoc  = currentRoomNum;
        shCurrentLoadNodeInfo.SHthisNodeType = SHgetLoadNodeTypefromStorage(currentRoomNum, loadNum);
        shCurrentLoadNodeInfo.SHthisNodeID   = SHgetLoadNodeIDfromStorage(currentRoomNum, loadNum);

        shCurrentLoadNodeInfo.SHthisNodeMsg.SHothrID = shThisNodeID; // this wall control is the other node ID to a load receiver node
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHmsgType = SH_MSG_ST_IDLE;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHcommand = SH_CMD_NOP;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusH = 0;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusL = 0;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusID = 0;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusVal = 0;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHreserved1 = SH_RESERVED_BYTE;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHreserved2 = SH_RESERVED_BYTE;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHchksum = 0;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHcalcChksum = 0;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusTX = 0;
        shCurrentLoadNodeInfo.SHthisNodeMsg.SHstatusRX = 0;

        // reset our command repeat counter for the new load, not counting them across different loads
        curSHcmdRepeats = 0;

        // Draw the new load name on the GUI display
        //lcdDrawLoadBtn(currentRoomNum, loadNum);  // Arduino function
        shGUIupdateLoadName(currentRoomNum, currentLoadNumInRoom);

        // Request current setting and powered state for drawing the current level indicator
//        shCurrentLoadNodeInfo.SHthisNodeIsPowered = SHloadRequestPoweredState(shCurrentLoadNodeInfo.SHthisNodeID);
//        shCurrentLoadNodeInfo.SHthisNodeLevelCurrent = SHloadRequestCurrentIntensity(shCurrentLoadNodeInfo.SHthisNodeID);
        shGetNewLoadCurIntensity = YES; // set flag to ask the load for current intensity via Zigbee/serial

        // Draw the effective current level indicator for this load to LCD
        //lcdDrawCurLevel();           // Arduino function
        SHguageDrawCurrentIntensity(); // Linux function

    }
    else
    {
        // invalid load number for this room, stay at current load number for this room
    }
}


void wxSmartHomeServerFrame::shGUIupdateRoomName(uint16_t roomNum)
{
    shCurrentRoomName = SHgetRoomNamefromStorage(roomNum);
    shTextCtrlRoomName->Clear();
    shTextCtrlRoomName->AppendText(shCurrentRoomName);
}


void wxSmartHomeServerFrame::shGUIupdateLoadName(uint16_t roomNum, uint8_t loadNum)
{
    shCurrentLoadName = SHgetLoadNamefromStorage(roomNum, loadNum);
    shTextCtrlLoadName->Clear();
    shTextCtrlLoadName->AppendText(shCurrentLoadName);
}

